<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[阿熊的Caddy+Hugo+Acme.sh配置填坑笔记]]></title>
    <url>%2F2018%2F01%2F05%2Fcaddy-hugo-acme%2F</url>
    <content type="text"><![CDATA[前言最近想比较一下caddy和nginx的服务及功能，设定的目标是用hugo搭建一个静态站点然后通过Caddy服务起来提供https://axiong.me 的访问。于是就走上了一条不断踩坑的不归路，在此记录一下踩坑、填坑的过程。第〇个踩到的坑：github的CNAME站点不支持https理论上站点也可以放在github的gh-pages上，所以我就尝试了Hugo托管到Github的流程说明Tips我用的是gh-pages的分支方案 项目master分支根节点可以加gitignore忽略掉hugo的发布路径public，方便测试 注意安装主题的话最好用submodule的方式而不是文档中的git clone,比如：1git submodule add https://github.com/christianmendoza/hugo-smpl-theme themes/hugo-smpl-theme这样后续部署的时候才不会遇到尴尬的项目没法自动部署的问题。问题github的CNAME站点不支持https不过@根域名CNAME记录和MX记录TXT记录冲突，蛋疼（免费邮局服务不想放），而且MD不支持https，所以，方案被我毙掉了。解决方案自己有vps就可以任性一下了，也顺便捣腾一下Caddy的https服务第一个踩到的坑：Caddy自动申请证书不成功就是Caddy自动申请 Let's Encrypt 的请求总是总是timeout， 不知道是不是因为解析服务用cloudxns的问题，而caddy目前还没有cloudxns的组件。解决方案用 Acme.sh 这个自动脚本做配置做证书的issue和renew，注意要采用dns的api模式,毕竟到这一步Caddy的服务还被申请证书卡着。参考：Acme.sh说明1. 证书申请1acme.sh --issue --dns -d axiong.me2. 到解析服务商后台添加对应的Txt记录我的是cloudxns基本上就是加一条的Txt类型记录，_acme-challenge为主host部分记录，内容部分是acme终端中给出的。3. 重新生成证书1acme.sh --renew -d axiong.me4. 到你的解析服务商后台申请API的key和secret参考链接Acme.sh的DNSApi的配置说明5. 导出/安装证书到本地供后续Caddy使用1acme.sh --installcert -d axiong.me --key-file /etc/ssl/caddy/certs/axiong.me/ssl.key --fullchain-file /etc/ssl/caddy/certs/axiong.me/fullchain.cer --reloadcmd &quot;systemctl restart caddy&quot;按照acme.sh的说明，它的crontab脚本会自动续期证书。免费ssl证书问题至此算是告一段落。第二个踩到的坑：Caddy+Hugo组合配置问题网上有Caddy+Hugo的教程:http://www.gohugo.org/post/qhsong-host-hugo-blog-using-caddy/https://laozhu.me/post/deploy-blog-with-caddy-and-hugo/都有一些小坑，比如：caddy的插件有依赖必须通过他官方的服务整合编译，上面的配置中依赖http.hugo,http.minify,http.git等caddy的官方下载如果插件加多了很可能给你返回500，安装失败caddy的hugo插件，hugo指令必须是环境变量里支持的，我适用golang开发环境的hugo如果作为系统服务就会找不到caddy的配置问题，errors节点里不能配置log指令解决方案查文档，看官方说明，例子。1. caddy+插件下载问题，至少需要http.git,http.minify,http.hugo精简插件数量只装必要的Caddy官方的下载页面可以定制，定制完毕页面最下方有命令行指令参考https://caddyserver.com/download一键安装指令：1curl https://getcaddy.com | bash -s personal dns,hook.service,http.git,http.hugo,http.minify,tls.dns.rfc2136或者用下载链接下载后解压缩后把caddy放到/usr/local/bin/caddy1wget -O &quot;caddy.tar.gz&quot; &quot;https://caddyserver.com/download/linux/amd64?plugins=dns,hook.service,http.git,http.hugo,http.minify,tls.dns.rfc2136&amp;license=personal&quot;2. hugo指令必须是环境变量里支持的,去官方直接下载发行版的安装包注意apt-get或者snap安装的版本会比较老，建议直接去 https://github.com/gohugoio/hugo/releases 下载 比如ubuntu用的.deb的包 下载后安装1sudo dpkg -i hugo_xxx_Linux-64bit.deb第三个踩到的坑：Caddy的ulimit问题其实不算是Caddy的锅，系统的limits配置我的vps没调整，Caddy会报1caddy: WARNING: File descriptor limit 1024 is too low for production servers. At least 8192 is recommended. Fix with &quot;ulimit -n 8192&quot;.解决方案临时解决方案就是执行提示里的1ulimit -n 8192再跑caddy，彻底的解决方案是修改系统的limits配置：1sudo vim /etc/security/limits.conf追加 对文件句柄的配置设定1234* soft nofile 65535* hard nofile 65535* soft nproc 65535* hard nproc 65535第四个踩到的坑：Caddy的默认端口是2015Caddy的配置有个坑，如果tls不是他它自动签发的模式，的情况下 http的端口用的是2015。参见https://github.com/mholt/caddy/issues/651https://github.com/mholt/caddy/issues/1673解决方案手工配置自动跳转1234567http://axiong.me &#123; redir https://axiong.me&#125;https://axiong.me &#123; tls ssl.cer ssl.key ...&#125;第五个踩到的坑：Caddy自启动的Systemd配置问题配置Caddy的Systemd自启动遇到1caddy.service: Failed at step NAMESPACE spawning /usr/local/bin/caddy: No such file or directory启动不了参考 https://caddy.community/t/starting-with-systemd-failed-at-step-namespace-spawning-usr-local-bin-caddy-no-such-file-or-directory/423改吧改吧，然后转角遇到爱，尼玛，又出现12ExecStart=/usr/local/bin/caddy -log stdout -agree=true -conf=/etc/caddy/Caddyfile -root=/var/tmp (code=exited, status=226/NAMESPACE) Main PID: xxx (code=exited, status=226/NAMESPACE)解决方案死活找不到原因，怒了，重新按社区贡献的配置文档重新整了一遍，参考 https://github.com/mholt/caddy/tree/master/dist/init/linux-systemd 文档，并下载caddy.service作为模板重新一步步把用户权限配置了一遍，搞定，不在出现226/NAMESPACE问题。优化完善Caddy配置查Caddy的官方文档，完整的解决配置文件Caddyfile内容问题修改后的完整示例：1234567891011121314151617181920212223242526272829303132333435http://axiong.me &#123; redir https://axiong.me&#125;https://axiong.me &#123; #tls off #tls admin@example.com tls /etc/ssl/caddy/certs/axiong.me/fullchain.cer /etc/ssl/caddy/certs/axiong.me/ssl.key minify gzip log / /var/log/caddy/pub-axiong.me_access.log &quot;&#123;combined&#125;&quot; &#123; rotate_size 100 # Rotate a log when it reaches 100 MB rotate_age 14 # Keep rotated log files for 14 days rotate_keep 10 # Keep at most 10 rotated log files rotate_compress # Compress rotated log files in gzip format &#125; errors /var/log/caddy/pub-axiong.me_error.log &#123; 404 404.html # Not Found rotate_size 100 # Rotate a log when it reaches 100 MB rotate_age 14 # Keep rotated log files for 14 days rotate_keep 10 # Keep at most 10 rotated log files rotate_compress # Compress rotated log files in gzip format &#125; root /var/www/axiong.me/public git &#123; repo https://github.com/nickfan/axiong.me path /var/www/axiong.me then hugo --destination=/var/www/axiong.me/public hook /webhook [你在github后台设置的webhook的口令] hook_type github clone_args --recursive pull_args --recurse-submodules interval 3600 &#125; hugo&#125;其中webhook就是你代码托管服务比如github上代码repo后台设定中添加一下webhook这样代码提交以后就会自动构建你的新静态网站 比如我的托管在github上webhook.settings设定在 https://github.com/nickfan/axiong.me/settings/hooks添加webhook,PayloadURL填写你域名/webhook，比如我的：1https://axiong.me/webhookcontent-type选json secret填写和Caddyfile中的口令保持一致 其他保持默认即可。至此Caddy才算是初步可以看了。有访问日志、有错误日志，日志都有rotate不会撑满磁盘。有minify+gzip做输出优化免费自定义ssl证书，有钱你换DV,OV级别的我也没意见自动http-&gt;https跳转改完站点提交代码后webhook自动发布上线TODOwebhook的配置可以从Caddyfile配置中用环境变量替换出来，放到Systemd的附加配置里，比如加个override.conf之类的，更完善。]]></content>
      <categories>
        <category>dev</category>
        <category>env</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>caddy</tag>
        <tag>hugo</tag>
        <tag>https</tag>
        <tag>systemd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android终端环境配置]]></title>
    <url>%2F2017%2F08%2F20%2Fandroid-termux%2F</url>
    <content type="text"><![CDATA[效果图惯例，先看最终执行效果图android客户端软件清单Termux无需root的终端app，基于busybox(可选) Hacker's Keyboard更舒服的编码键盘(可选) Quick Keyboard Switch快速切换键盘（通知栏输入法切换）(可选) Remote Keyboard非常简单的远程键盘输入，你所需要的只是一个telnet终端工具（windows的telnet命令或者SecureCRT,XShell之类的都可以） 打开Remote Keyboard后会告诉你本机的服务地址和端口 同时你选中的输入法是Remote Keyboard 在你的终端工具/指令中连接上此ip端口即可1telnet 192.168.1.247 2323然后就尽情的输入吧，不过话说，有台式机还要在手机玩，应该是缺乏安全感吧。(备用) Terminal IDE这货也是基于busybox的，不过属于一次性集成n多包的那种，目前没看到追加包的办法只有rpm指令，如果内置的功能够用，这个备选也不错。(推荐) JuiceSSH - SSH Client如果你仅仅是需要远程登录到服务器临时解决一下问题的话这个ssh终端工具也许会更适合你。准备如果你愿意认真读Termux的帮助文档，这里的很多废话可以略过，想省时间的话看下面：触屏键盘触屏键盘手机的实体键位中的音量减相当于linux中的Control键(CTRL)触屏键盘手机的实体键位中的音量加相当于linux中的Alt键(ALT)或一些特殊功能键触屏键盘记得按音量加 + Q键 开启扩展功能键视图会比较方便输入安装包管理器debian/ubuntu的包管理器的那一套的简装版安装包install xxx```12* 搜索包 ```apt search xxx卸载包remove xxx```12* 列出已安装包 ```apt list --installed所有的apt命令也可以用pkg命令替代 比如pkg install 等价于apt install我本地配置基本环境所用到的包清单：123456789101112131415aria2coreutilscurlgitgolanggziplesslftpnanoopensshscreenfetchvimwgetzshtermux-tools挂载点配置运行指令：1termux-setup-storage具体的挂载点可以参考 https://termux.com/storage.html 在这里就不展开说了交互终端配置你可以安装zsh来提供更便捷的使用体验1apt install zsh切换zsh为默认shell:1chsh -s zsh注意你的配置里locale的设置应该会无效，至少我目前是把服务端的.profile修改后再使用的默认的zsh啥也木有，而网上的oh-my-zsh又没办法直接安装在termux里 有人已经做好了移植版：https://github.com/Cabbagec/termux-ohmyzsh安装指令：12sh -c &quot;$(curl -fsSL https://github.com/Cabbagec/termux-ohmyzsh/raw/master/install.sh)&quot;记得先apt install 我上面包列表中的curl至少。最后可以根据自己的个人喜好修改一下~/.zshrc配置中的主题个人比较喜好ys主题，诸君请随意。手机ssh服务除了Remote Keyboard这种歪脖看手机屏幕，电脑键盘打字的方式，更传统的方式是把手机当服务器ssh连进来玩。apt install openssh 之后即可，不过有几点注意的地方：sshd需要手工跑一下有1024低端口安全限制所以这里sshd的服务是开在8022端口上的因为Termux是不需要root的系统，所以一般情况下你登录的用户名需要你自己看一下：1whoamissh登录是key公钥模式登录，你可以先手工scp远程的公钥到本地的路径再cat追加到~/.ssh/authorized_keys中然后在客户机以密钥对的私钥登录1ssh -p8022 xxx@192.168.1.247其中xxx是你whoami中查到的值如果你要从手机上ssh到其他服务器最简单的办法，copy私钥到~/.ssh/id_rsa位置然后在zsh里开启ssh-agent插件:1plugin=(git ssh-agent)或者你也可以试试在自己的.profile或者其他交互启动脚本中追加：1234if [ -f ~/.ssh/id_rsa ]; then ssh-add -K ~/.ssh/id_rsa 2&gt;/dev/nullfi杂谈这货虽然是busybox组装的但是基础组件都能慢慢堆叠，虽然环境简陋了点，但好歹真正的应急移动办公也算有点着落另外私钥还是要保管好的说。除此之外，有aria2可以用来当下载服务用，路径记得设在外面的挂载点里，配合android端的ui，你懂的。golang装好了之后还能起个本地web服务玩玩，总之爱折(zhuang)腾(bi)的朋友不容错过。]]></content>
      <categories>
        <category>dev</category>
        <category>env</category>
      </categories>
      <tags>
        <tag>mobile-dev</tag>
        <tag>android</tag>
        <tag>termux</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github上hexo静态博客自动部署配置笔记]]></title>
    <url>%2F2017%2F07%2F25%2Fgithub-blog-setup%2F</url>
    <content type="text"><![CDATA[前言越来越觉得时间不够用，千头万绪，容我喝口水。。写blog的频率还赶不上wordpress的安全更新的推送频率，思考了一下还是决定把博客迁移到github上来，动机：wordpress的强大对于我等懒人实在是太折腾了。https+全静态，后续维护不想再折腾太多。不怕忘了续费，哪怕百年之后也算留点痕迹。(但愿github在10年之内能继续服务下去，至少感觉比国内的服务靠谱一点，关站的几率较小)方案目前来说看了一眼 https://www.staticgen.com/jekyll最火，ruby的，环境配置方面感觉有点担心 hugo其次, golang的，虽然最快，最强大，但从写博客的角度出发而言，用静态建站工具来搞，略有点繁杂，而且貌似教程不多。 hexo再次，node的，教程挺多，还有比较成熟的主题，就他了。建站工具: hexo + NexT 主题模板github公共主页静态页面网站bitbucket后端项目源码codeship持续集成自动发布预备git本地配置+ssh公钥配置github账号bitbucket账号codeship账号安装安装hexo1npm install -g hexo-cli生成并初始化博客1hexo init myblog安装NexT主题 (下载最新版本的主题并mv到myblog/themes/next路径)12345cd myblogwget https://github.com/iissnan/hexo-theme-next/archive/v5.1.1.tar.gztar zxf v5.1.1.tar.gzmv hexo-theme-next-5.1.1 themes/nextrm -rf v5.1.1.tar.gz参考链接:手把手教你使用Hexo + Github Pages搭建个人独立博客史上最详细的Hexo博客搭建图文教程NexT主题配置流程hexo 官方中文文档按参考链接中的说明配置好你的站点 _config.yml 配置文件和主题配置文件 themes/next/_config.yml使用基本页面关于 页面1hexo new page about内容自己填写tags 页面1hexo new page tags内容：123456---title: tagsdate: 2017-07-25 15:06:12type: &quot;tags&quot;comments: false---categories 页面1hexo new page categories内容：123456---title: categoriesdate: 2017-07-25 16:21:02type: &quot;categories&quot;comments: false---新建文章1hexo new &quot;hello world&quot;文章源文件存储在source/_posts/不用的文章删掉文件重新发布即可。本地测试1hexo s -g访问 http://localhost:4000 预览效果。清理1hexo clean手工发布1hexo d -g自动发布配置在bitbucket上新建私有项目（部分配置key需要保密）在codeship中导入此私有项目在codeship中查看deploy-keys发布公钥，并在github的对应静态站点中配置此发布公钥并允许write写入权限配置codeship基础setup初始化指令：123456789nvm install 6.11.1npm install hexo-cli -gnpm install# or, if you prefer to use yarn#yarn installgit config --global user.email &quot;yourname@example.com&quot;git config --global user.name &quot;yourname&quot;注意记得指令中配置git的全局配置，不然部署流程可能失败删掉test的commands的pipeline 指令，不需要配置deploy部署指令的分支为master配置部署指令的脚本为custom scripts:12hexo cleanhexo d -g注意：如果你使用了algolia的三方服务组件的情况下： 你的codeship配置中环境变量要加上HEXO_ALGOLIA_INDEXING_KEY的变量 并且在algolia 新建对应的索引用的apikey，设置流程参考：hexo-algolia部署脚本的指令也要改为：1234hexo cleanhexo ghexo algoliahexo d写点内容到你的博客中，并提交push到bitbucket的项目中去(source/_posts/中新建xxx.md的日志文件)等着发布完成的通知查看你的静态博客站点看效果吧。当前这篇文章就是在bitbucket的在线创建文件编辑器(支持markdown)中编写的。TODO在线图床可以用imgur或者七牛的服务，如果写文字为主也可以本地存图，完整的想好好的像medium、简书之类的服务在线码字贴图的话，一种方案就是写个前后端编辑器处理上传文件服务和提交/获取bitbucket项目文件。 再牛一点就是纯h5方案前端集成图床的api接口+bitbucket的服务接口。]]></content>
      <categories>
        <category>dev</category>
        <category>deployment</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>static-site</tag>
        <tag>hexo</tag>
        <tag>deployment</tag>
        <tag>ci</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下基础开发环境搭建]]></title>
    <url>%2F2016%2F05%2F28%2Fwindows-dev-env-setup%2F</url>
    <content type="text"><![CDATA[工作需要在windows环境下搭建一个基础开发环境，在此记录一下：一、注意事项以下的安装配置方法仅支持win7/8/10之类的系统，xp可以洗洗睡了。装了cmder-full(With git-for-windows)版或者babun就没有必要安装git-for-windows了，不过从兼容性角度出发，建议还是使用cmder-full的版本，至少纯windows的环境下也能直接使用git指令，也支持外部ide调用。babun（cygwin）是调整过的cygwin环境,cmder默认是windows环境(可以安装chocolatey做包管理)两个环境面对的场景不同，choco安装的软件基本都是port到win环境下的版本，和babun的cygwin环境下的版本配置方式不一样，看各人喜好，可以分别使用，也可以只使用一个。linux的家HOME目录用~字符来标识，windows下通常对应的就是C:\Users\Administrator目录二、终端环境推荐使用cmder(With git-for-windows) + babun(cygwin)预配置环境的方式，既有普通cmd终端的linux化，又支持cygwin环境安装使用你所需要的linux环境安装包cmder-full（With git-for-windows）下载后解压缩到磁盘，（推荐c:\opt\cmder）加入系统环境变量PATH环境变量中追加c:\opt\cmder路径。注册右键菜单：以管理员身份启动命令行提示符(cmd)，然后进入c:\opt\cmder路径后执行：1Cmder.exe /REGISTER ALL提示符配置：修改cmder目录下的config\cmder.lua的第2行把λ替换为$,更符合日常linux下用户prompt的习惯。123function lambda_prompt_filter() clink.prompt.value = string.gsub(clink.prompt.value, &quot;&#123;lamb&#125;&quot;, &quot;$&quot;)end常用别名配置：修改cmder目录下的config\alias文件，在最后加入常用的alias，比如：123l=ls --show-control-charsla=ls -aF --show-control-chars ll=ls -alF --show-control-chars中文字间距问题，启动cmder后win+alt+p呼出设置面板去掉 monospace 选项（点两下让勾选框留空），然后save settings保存设置。可选（安装chocolatey windows包管理器），打开cmder/cmd终端，执行以下命令：1@powershell -NoProfile -ExecutionPolicy Bypass -Command &quot;iex ((new-object net.webclient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))&quot; &amp;amp;&amp;amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin安装babun的环境：下载babun官网上的安装包，解压后执行其中的install.bat批处理文件配置整合babun环境到cmder工具中：启动cmder后win+alt+p呼出设置面板(Settings)，然后打开 Startup&gt;Tasks面板点+号添加一个task，名称输入babun， Task parameters中输入：1/icon &quot;%userprofile%\.babun\cygwin\bin\mintty.exe&quot; /dir &quot;%userprofile%&quot;下面的Commands大输入文本框中输入：1%userprofile%\.babun\cygwin\bin\mintty.exe /bin/env CHERE_INVOKING=1 /bin/zsh.exesave settings保存设置，然后你可以按up或down的按钮把{babun}的顺序调到{cmd}的前后，也可以勾选Default task for new console和Default Shell选项来把它作为默认console。注意，如果新开窗口想默认用{babun}，需要修改Startup面板中的Specified named task不选{cmd}而是新的这个{babun}修改babun的环境配置：cmder启动后打开{babun}的终端后编辑~/.zshrc文件：1vim ~/.zshrc修改ZSH_THEME=&quot;babun&quot;为ZSH_THEME=&quot;ys&quot;，后保存退出，然后关闭终端后再启动{babun}终端即可。如果你还是习惯mingw的git-bash环境也可以在cmder工具中添加配置：启动cmder后win+alt+p呼出设置面板(Settings)，然后打开 Startup&gt;Tasks面板点+号添加一个task，名称输入gitbash，Task parameters中留空下面的Commands大输入文本框中输入：1%ConEmuDir%\..\git-for-windows\git-cmd.exe --cd-to-home --command=usr/bin/bash.exe -l -isave settings保存设置即可，后续的就可以启动{gitbash}终端使用了。至此你已经完成了windows下终端环境的配置，启动cmder后，{cmd}的task为windows上下文命令行：使用choco作为包管理器 同时也支持一些基本的linux命令比如ls,curl之类的，软件包管理可以使用chocolatey的choco指令，search notepad1choco install -y notepadplusplus{babun}的task为cygwin上下文命令行：使用pact作为包管理器12pact find phppact install -y php注意{babun}的cygwin环境上下文中的安装的包不能在windows上下文环境中使用，（比如这里安装的php指令在windows环境下则会报招不到php指令），但windows上下文环境中安装的软件可以在cygwin环境下最后被搜索到则调用，注意是调用，效率比较低，而且也无法控制执行，所以通常情况下的windows指令还是推荐在{cmd}终端中执行。命令行生成私钥公钥对：1ssh-keygen -t rsa -C &quot;you@myteam&quot;默认生成的文件在~/.ssh路径下的id_rsa(私钥)和id_rsa.pub(公钥)，id_rsa.pub可以添加到代码托管环境的个人公钥列表中去设置个人基础的git信息:12git config --global user.name &quot;你的名字或昵称&quot;git config --global user.email &quot;你的邮箱&quot;三、开发环境(virtualbox+ vagrant[homestead]|docker[laradock])安装 virtualbox和其下载页面的Oracle VM VirtualBox Extension Pack扩展包安装vagrant工具以vagrant（homestead）为例子构建开发环境: {cmd}命令行输入:1vagrant box add laravel/homestead下载比较慢，你可以在这里： https://atlas.hashicorp.com/laravel/boxes/homestead 查到版本号，然后手工下载官方的链接，比如0.4.4的版本： https://atlas.hashicorp.com/laravel/boxes/homestead/versions/0.4.4/providers/virtualbox.box 注意部分下载工具比如迅雷可能会导致下载的box文件损坏从而无法导入。 下载好后，放到可以被当前用户命令行访问到的地方然后执行：1vagrant box add laravel/homestead /Path/to/Homestead.box/Path/to/Homestead.box就是你下载的box文件的完整访问路径。 导入成功后此时的box是没有版本信息的，你需要手工修正这个版本的问题：12cd ~/.vagrant.d/boxes/laravel-VAGRANTSLASH-homestead mv 0 0.4.4将0目录改名成0.4.4名称 然而此时的手工添加的方式没有升级信息需要手工添加metadata_url这个文件到系统下：12cd ~/.vagrant.d/boxes/laravel-VAGRANTSLASH-homestead vim metadata_url内容输入：1https://atlas.hashicorp.com/laravel/homestead注意如果是手工编辑的此文件，不要有任何形式的回车换行符和空格等无效内容，保存后退出vim 接下来就可以开始homestead的基础安装了，返回到$HOME路径：12cd ~ git clone https://github.com/laravel/homestead.git ~/Homestead你也可以使用我定制过的版本 【首次provision的时候，你网络没问题的话，自动帮你搞定以下问题】国内apt源 oh-my-zsh安装配置 略调整过的vim环境配置 composer环境加 中文源 laravel-envoy部署工具、laravel命令行工具、box(phar打包工具) psysh 交互式php命令行工具 cnpm 国内源npm phpunit命令行工具 命令行代理服务、工具privoxy proxychains 命令行科学上网工具，shadowsocks(sslocal/ssserver)+配置更新脚本 （懂得同学最好还是换成自己的配置/home/vagrant/etc/shadowsocks.json，并注释掉/etc/cron.d/ssupdateinfo中的对配置更新脚本的调用/home/vagrant/bin/upssinfo.sh） 喜欢折腾的童鞋可以fork我的改版后自己修改 scripts/pre-setup.sh和scripts/post-setup.sh脚本。 12cd ~ git clone https://github.com/nickfan/homestead.git ~/Homestead然后进入~/Homestead后执行：12cd ~/Homestead/ bash init.sh这个步骤会自动生成 ~/.homestead/Homestead.yaml的虚拟机配置文件，根据你自己的需要做对应的定制，比如我的：12345678910111213141516171819202122232425262728293031323334--- ip: &quot;192.168.70.10&quot; memory: 2048 cpus: 1 provider: virtualbox authorize: ~/.ssh/id_rsa.pub keys: - ~/.ssh/id_rsa folders: - map: ~/Code to: /home/vagrant/Code sites: - map: homestead.app to: /home/vagrant/Code/homesteadapp/public databases: - homestead # blackfire: # - id: foo # token: bar # client-id: foo # client-token: bar # ports: # - send: 50000 # to: 5000 # - send: 7777 # to: 777 # protocol: udp注意的一点是~/Code也就是C:\Users\Administrator\Code目录不能是软链的目录而必须是实体目录，否则在virtualbox挂载的时候会报错。 然后回到~/Homestead执行：12cd ~/Homestead vagrant up执行首次启动的provision流程。 后续的执行只需要vagrant up即可。vagrant halt关闭虚拟机。 如果provision的过程中网络出现问题等其他虚拟机被弄乱的情况还可以 vagrant destroy --force来强行删除掉虚拟机，再vagrant up来重新provision一遍。 其他homestead的安装细节可以参考：http://laravel-china.org/docs/5.1/homestead如果你比较熟悉docker也可以安装新的docker-tools集成docker工具集 安装的时候，前面你已经独立安装过了virtualbox和cmder(git-for-windows)所以此处安装时，请不用勾选 VirtualBox和Git for Windows两个选项 安装路径，推荐改为C:\opt\docker-toolbox 方便后续命令行操作时的输入。&lt;/p&gt;集成docker的启动命令： 在cmder工具中添加配置：启动cmder后win+alt+p呼出设置面板(Settings)，然后打开 Startup&gt;Tasks面板点+号添加一个task，名称输入docker， Task parameters中输入：1/dir &quot;C:\opt\docker-toolbox&quot; /icon &quot;C:\opt\docker-toolbox\boot2docker.ico&quot;下面的Commands大输入文本框中输入：1&quot;-new_console:C:C:\opt\docker-toolbox\boot2docker.ico&quot; -new_console:n -new_console:t:Boot2Docker &quot;-new_console:d:C:\opt\docker-toolbox&quot; &quot;%ConEmuDir%\..\git-for-windows\bin\sh.exe&quot; --login -i &quot;C:\opt\docker-toolbox\start.sh&quot;save settings保存设置即可，后续的就可以启动{docker}终端使用了。 另外如果docker-toolbox安装时是独立安装的git-for-windows（像我们前面描述的这样）需要手工修改桌面和开始菜单中的快捷方式Docker Quickstart Terminal，把目标程序的命令行内容改为：1C:\opt\cmder\vendor\git-for-windows\bin\bash.exe --login -i &quot;C:\opt\docker-toolbox\start.sh&quot;以docker(laradock)为例子构建开发环境 你可以clone官方的版本：12cd ~/Code git clone https://github.com/LaraDock/laradock.git然后修改docker-compose.yml配置文件中的application的volumes设置：123456### Laravel Application Code Container ###################### application: build: ./application volumes: - ../:/var/www/laravel改为：123456### Laravel Application Code Container ###################### application: build: ./application volumes: - ../dockerapp/:/var/www/laravel也可以直接clone我改好的版本12cd ~/Code git clone https://github.com/nickfan/laradock.git然后可以把Code下 前面构建好的homesteadapp做个软链到dockerapp，这样可以只用一套代码1234cd ~/Code ln -nfs homesteadapp dockerapp #或者windows上下文的 mklink /d dockerapp homesteadapp最后初始化docker环境：1docker-compose up nginx mysql redis剩下的调整配置、和使用部分可以参考官方文档：https://github.com/LaraDock/laradock其他推荐软件以下软件都可以用 chocolatey windows下的命令行包管理器 来安装，安装/卸载软件并不需要用到那些什么软件管理专家了。wox windows下类似于mac的alfred的快速启动工具，有了它记得软件、目录名字就可以了，忘了开始菜单吧。everything windows下的文件搜索工具，这个就不用多说了吧。]]></content>
      <categories>
        <category>dev</category>
      </categories>
      <tags>
        <tag>babun</tag>
        <tag>cmder</tag>
        <tag>cygwin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Laravel Envoy的部署脚本]]></title>
    <url>%2F2015%2F07%2F21%2Fenvoy-deployscript%2F</url>
    <content type="text"><![CDATA[如题，找了半天貌似都没有符合laravel的天朝网络环境的的部署脚本， 于是乎结合参考了多个部署脚本和工具的理念又造了个新轮子：https://github.com/nickfan/envoy-deployscript使用说明见：https://github.com/nickfan/envoy-deployscript/blob/master/README.zh-CN.md欢迎大家测试吐槽。主要特点：支持本地构建打包部署1envoy run deploy_localrepo_install --branch=master --env=production支持工作拷贝本地构建依赖模块(vendor目录)1envoy run deploy_mix_pack原理/设计规划你的 $deploybasepath 远程部署基础路径将会看起来像如下这样(如果你有多个子应用在同一个部署基路径里).123mysite/mysite2/mysite3/你的 $deploybasepath/$appname 远程部署应用路径将会看起来如下.123456releases/release_20150717032737/releases/release_20150717034646/current -&gt; ./releases/release_20150717034646shared/storage/tmp/.env正如你所见的, current 目录是软链到最近一次的部署目录的在你的部署目录中文件列表看起来像下面这样(只列举了部分文件做例子):12345678app/artisanboostrap/public/index.phpcomposer.json.env -&gt; ../../.envstorage -&gt; ../../shared/storagevendor/部署目录中的.env文件和storage文件夹都软链接到了上级应用目录中的公共文件/文件夹了,这样部署本身只部署源代码和vendor等依赖环境, storage等公共数据在shared文件夹中并不随代码部署,节省了空间也保留延续了日志/应用cache等相关基础数据在应用中的使用]]></content>
      <categories>
        <category>dev</category>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>deploy</tag>
        <tag>envoy</tag>
        <tag>laravel</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个简单的php守护进程代码示例]]></title>
    <url>%2F2015%2F07%2F08%2Fsimple-php-daemon-code%2F</url>
    <content type="text"><![CDATA[工作中同事需要做一个简单的工作进程，需要在进程结束时不能被硬生生的掐断当前正在执行的工作流程，需要等一个处理流程跑完了再结束，所以这时候就需要用到pcntl的信号量来工作了，主要的设计思路：捕获系统发给进程的中断的信号量在handler代码中设置标志位变量在一个业务循环处理完成之后判断标志位变量，如果接收到过终止请求，则跳出整个工作循环。 主要的处理逻辑：注册绑定函数：1234567protected function regist_sig_handler()&#123; declare(ticks = 1); pcntl_signal(SIGTERM, [$this, &apos;sig_handler&apos;]); pcntl_signal(SIGHUP, [$this, &apos;sig_handler&apos;]); pcntl_signal(SIGINT, [$this, &apos;sig_handler&apos;]);&#125;在函数中设置标志位：1234567891011protected function sig_handler($signo) &#123; switch ($signo) &#123; case SIGTERM: case SIGHUP: case SIGINT: self::$_MYDAEMON_SHOULD_STOP = true; // ... break; &#125; &#125;构建退出处理函数12345678910protected function shouldStop() &#123; if (self::$_MYDAEMON_SHOULD_STOP) &#123; // before exit staff code // ... return true; &#125; return false; &#125;在主循环中一次处理完成后判断是否要终止退出1234567891011while (true) &#123; if ($this-&gt;shouldStop()) &#123; break; &#125; try &#123; $jobStatusInfo = $this-&gt;execute([]); &#125; catch (Exception $ex) &#123; $this-&gt;log($ex-&gt;getMessage()); &#125; usleep(10);&#125;附上完整代码（loop是示例需要长时间处理的业务逻辑，memoryusage超限也会退出，外部可以由supervisor/daemontools等进程监控程序控制）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#!/usr/bin/env php&amp;lt;?php/** * Description * * @project mydevkit * @package mydevkit * @author nickfan &amp;lt;nickfan81@gmail.com&gt; * @link http://www.axiong.me * @version $Id$ * @lastmodified: 2015-07-08 09:37 * */@set_time_limit(0);class myDaemon&#123; const DEBUG = true; protected static $_MYDAEMON_SHOULD_STOP = false; public static $memLimit = 5242880; private $loop = 10; protected $logpath = &apos;&apos;; public function __construct($option = []) &#123; $option += [ &apos;loop&apos; =&gt; 10, &apos;memLimit&apos; =&gt; 5242880, &apos;logpath&apos; =&gt; &apos;/tmp/daemon_kill.log&apos;, ]; $this-&gt;loop = $option[&apos;loop&apos;]; $this-&gt;logpath = $option[&apos;logpath&apos;]; self::$memLimit = $option[&apos;memLimit&apos;]; $this-&gt;regist_sig_handler(); &#125; public function __destruct() &#123; $this-&gt;log(&apos;worker progress ending...&apos;); &#125; protected function regist_sig_handler() &#123; declare(ticks = 1); pcntl_signal(SIGTERM, [$this, &apos;sig_handler&apos;]); pcntl_signal(SIGHUP, [$this, &apos;sig_handler&apos;]); pcntl_signal(SIGINT, [$this, &apos;sig_handler&apos;]); &#125; protected function sig_handler($signo) &#123; switch ($signo) &#123; case SIGTERM: case SIGHUP: case SIGINT: self::$_MYDAEMON_SHOULD_STOP = true; $signoStr = &apos;&apos;; if ($signo == SIGTERM) &#123; $signoStr = &apos;SIGTERM&apos;; &#125; elseif ($signo == SIGHUP) &#123; $signoStr = &apos;SIGHUP&apos;; &#125; elseif ($signo == SIGINT) &#123; $signoStr = &apos;SIGINT&apos;; &#125; $content = date(&apos;Y-m-d H:i:s&apos;) . &apos; &apos; . $signoStr . PHP_EOL; file_put_contents($this-&gt;logpath, $content, FILE_APPEND); break; &#125; &#125; protected function shouldStop() &#123; if (self::$_MYDAEMON_SHOULD_STOP) &#123; // before exit staff code // ... return true; &#125; return false; &#125; protected function log() &#123; $args = func_get_args(); $retstr = date(&apos;[Y-m-d H:i:s] &apos;) . implode(&apos; &apos;, $args) . PHP_EOL; if (self::DEBUG == true) &#123; echo $retstr; &#125; else &#123; return $retstr; &#125; &#125; public function execute($data = []) &#123; $this-&gt;log(&apos;[EXECUTE] process lot of data.&apos;); for ($i = 0; $i &amp;lt; $this-&gt;loop; $i++) &#123; $this-&gt;log(&apos;step:&apos; . ($i + 1)); sleep(1); &#125; return rand(1, $this-&gt;loop); &#125; public function run() &#123; $this-&gt;log(&apos;[RUN] worker starting to run ...&apos;); while (true) &#123; if ($this-&gt;shouldStop()) &#123; break; &#125; $this-&gt;log(&apos;processJobData Start ...&apos;); try &#123; $jobStatusInfo = $this-&gt;execute([]); $this-&gt;log(&apos;processJobData end with: &apos; . var_export($jobStatusInfo, true)); unset($jobStatusInfo); &#125; catch (Exception $ex) &#123; $this-&gt;log($ex-&gt;getMessage()); &#125; $memory = memory_get_usage(); $this-&gt;log(&apos;memory usage:&apos; . sprintf(&apos;%.2fMB&apos;, round($memory / 1048576, 2))); if ($memory &gt; self::$memLimit) &#123; $this-&gt;log(&apos;exiting run due to memory limit&apos;); exit; &#125; //sleep(1); usleep(10); &#125; $this-&gt;log(&apos;[RUN] worker run quit.&apos;); &#125;&#125;$gotMyParam = 10;if (isset($argv[1])) &#123; $gotMyParam = intval(trim(strip_tags($argv[1])));&#125;$worker = new myDaemon([&apos;loop&apos; =&gt; $gotMyParam, &apos;memLimit&apos; =&gt; 1048576 * 128,]);$worker-&gt;run();也可以到我的coding上下载：https://coding.net/u/nickfan/p/mydevkit/git/blob/master/bin/daemon测试：在class代码中的构造函数中注释掉1//$this-&gt;regist_sig_handler();运行daemon代码，在执行execute的for循环时ctrl+c或者用 kill 杀死当前进程进程直接结束，没有执行完execute的一个完整流程就直接退出了，把注释去掉重新执行daemon代码：在执行过程中按ctrl+c或者kill命令杀死前进程观察daemon运行的结果是直到整个execute循环执行完了以后才退出程序的]]></content>
      <categories>
        <category>dev</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel的oauth2-server相关开发的备忘]]></title>
    <url>%2F2015%2F07%2F01%2Flaravel-oauth2-tips%2F</url>
    <content type="text"><![CDATA[开发当中踩了不少坑，做个备忘。代码环境：laravel 5.1oauth2-server服务组件：lucadegasperi/oauth2-server-laravel 也就是 thephpleague/oauth2-server 的laravel 包装版本目前插件的版本是~4.1需要注意的点是：一般而言最常见的应用场景是grant_type为authorization_code的情景，thephpleague的oauth2-server要求的数据提交必须是POST数据编码方式是application/x-www-form-urlencoded，默认情况下如果你用的是curl组件会以multipart/form-data模式编码提交的post数据，所以后端提交请求的时候注意一下， 如果你用的是curl，需要设置：1curl_setopt($ch, CURLOPT_HTTPHEADER, array(&apos;Content-Type: application/x-www-form-urlencoded&apos;));如果你用的是GuzzleHttp的组件：参考官方的说明：123456789$response = $client-&amp;gt;post(&apos;http://httpbin.org/post&apos;, [ &apos;form_params&apos; =&amp;gt; [ &apos;field_name&apos; =&amp;gt; &apos;abc&apos;, &apos;other_field&apos; =&amp;gt; &apos;123&apos;, &apos;nested_field&apos; =&amp;gt; [ &apos;nested&apos; =&amp;gt; &apos;hello&apos; ] ]]);其他的基础配置设定,插件作者的wiki中已经有了说明，我这里做了一些自己的设定：不想关闭全局的csrf保护咋办？ 如果你是直接安装的laravel 5.1版不要关闭全局$middleware的csrf：123456789 protected $middleware = array( \Illuminate\Foundation\Http\Middleware\CheckForMaintenanceMode::class, \LucaDegasperi\OAuth2Server\Middleware\OAuthExceptionHandlerMiddleware::class, \App\Http\Middleware\EncryptCookies::class, \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class, \Illuminate\Session\Middleware\StartSession::class, \Illuminate\View\Middleware\ShareErrorsFromSession::class, \App\Http\Middleware\VerifyCsrfToken::class, // 不要关闭);按wiki中的说明添加$routeMiddleware中的设定：123456789protected $routeMiddleware = [ &apos;csrf&apos; =&amp;gt; \App\Http\Middleware\VerifyCsrfToken::class, // 添加 csrf配置 &apos;auth&apos; =&amp;gt; \App\Http\Middleware\Authenticate::class, &apos;auth.basic&apos; =&amp;gt; \Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class, &apos;guest&apos; =&amp;gt; \App\Http\Middleware\RedirectIfAuthenticated::class, &apos;oauth&apos; =&amp;gt; \LucaDegasperi\OAuth2Server\Middleware\OAuthMiddleware::class, &apos;oauth-owner&apos; =&amp;gt; \LucaDegasperi\OAuth2Server\Middleware\OAuthOwnerMiddleware::class, &apos;check-authorization-params&apos; =&amp;gt; \LucaDegasperi\OAuth2Server\Middleware\CheckAuthCodeRequestMiddleware::class,];在你的\App\Http\Middleware\VerifyCsrfToken类中的$except变量添加：123456protected $except = [ // &apos;api&apos;, &apos;api/*&apos;, &apos;oauth/access_token&apos;,];也就是：你的oauth服务获取access_token的入口地址，如果你换了地址修改这里对应的设置即可。你使用oauth中间件保护的服务接口也不需要csrf做多余的防护，在此排除掉 api/* 这对应的前缀即可 如果是5.0之类的升级上来的，VerifyCsrfToken可能还是老的写法，不支持$except，自己改造一下符合新版规范：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?php namespace App\Http\Middleware;use Closure;use Illuminate\Foundation\Http\Middleware\VerifyCsrfToken as BaseVerifier;use Illuminate\Session\TokenMismatchException;class VerifyCsrfToken extends BaseVerifier &#123; /** * The URIs that should be excluded from CSRF verification. * * @var array */ protected $except = [ // &apos;api/*&apos;, &apos;oauth/access_token&apos;, ]; /** * Handle an incoming request. * * @param \Illuminate\Http\Request $request * @param \Closure $next * @return mixed */ public function handle($request, Closure $next) &#123; if ($this-&amp;gt;isReading($request) || $this-&amp;gt;shouldPassThrough($request) || $this-&amp;gt;tokensMatch($request)) &#123; return $this-&amp;gt;addCookieToResponse($request, $next($request)); &#125; throw new TokenMismatchException; //return parent::handle($request, $next); &#125; /** * Determine if the request has a URI that should pass through CSRF verification. * * @param \Illuminate\Http\Request $request * @return bool */ protected function shouldPassThrough($request) &#123; foreach ($this-&amp;gt;except as $except) &#123; if ($request-&amp;gt;is($except)) &#123; return true; &#125; &#125; return false; &#125;&#125;本地登录授权的页面（View::make('oauth.authorization-form')）该怎么写？ 原来官方的wiki中没有，放狗找了一圈的issue list才凑合着写了一个放了上去，作者插件的wiki里我已改过了：注意提交的form原先GET请求中的querystring是需要一并post的 这个坑要注意一下。1234567891011121314151617181920@extends(&apos;app&apos;)@section(&apos;content&apos;) &amp;lt;div class=&quot;row&quot;&amp;gt; &#123;!! Form::open([&apos;method&apos; =&amp;gt; &apos;POST&apos;,&apos;class&apos;=&amp;gt;&apos;form-horizontal&apos;, &apos;url&apos;=&amp;gt; route(&apos;oauth.authorize.post&apos;,$params)]) !!&#125; &amp;lt;div class=&quot;form-group&quot;&amp;gt; &amp;lt;dl class=&quot;dl-horizontal&quot;&amp;gt; &amp;lt;dt&amp;gt;Client Name&amp;lt;/dt&amp;gt; &amp;lt;dd&amp;gt;&#123;&#123;$client-&amp;gt;getName()&#125;&#125;&amp;lt;/dd&amp;gt; &amp;lt;/dl&amp;gt; &amp;lt;/div&amp;gt; &#123;!! Form::hidden(&apos;client_id&apos;, $params[&apos;client_id&apos;]) !!&#125; &#123;!! Form::hidden(&apos;redirect_uri&apos;, $params[&apos;redirect_uri&apos;]) !!&#125; &#123;!! Form::hidden(&apos;response_type&apos;, $params[&apos;response_type&apos;]) !!&#125; &#123;!! Form::hidden(&apos;state&apos;, $params[&apos;state&apos;]) !!&#125; &#123;!! Form::submit(&apos;Approve&apos;, [&apos;name&apos;=&amp;gt;&apos;approve&apos;, &apos;value&apos;=&amp;gt;1, &apos;class&apos;=&amp;gt;&apos;btn btn-success&apos;]) !!&#125; &#123;!! Form::submit(&apos;Deny&apos;, [&apos;name&apos;=&amp;gt;&apos;deny&apos;, &apos;value&apos;=&amp;gt;1, &apos;class&apos;=&amp;gt;&apos;btn bg-danger&apos;]) !!&#125; &#123;!! Form::close() !!&#125; &amp;lt;/div&amp;gt;@endsection而对应的$params在controller中的设置：1234$authParams = Authorizer::getAuthCodeRequestParams();$formParams = array_except($authParams,&apos;client&apos;);$formParams[&apos;client_id&apos;] = $authParams[&apos;client&apos;]-&amp;gt;getId();return View::make(&apos;oauth.authorization-form&apos;, [&apos;params&apos;=&amp;gt;$formParams,&apos;client&apos;=&amp;gt;$authParams[&apos;client&apos;]]);最后在你被oauth保护的api接口中你就可以获得到对应的当前用户id了：1$uid = Authorizer::getResourceOwnerId();]]></content>
      <categories>
        <category>dev</category>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>php</tag>
        <tag>oauth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[世界，你好！]]></title>
    <url>%2F2015%2F03%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[再一次搬家，其实写博客在现代而言已经貌似成为了史前人类的习惯，之前博客的数据也感觉鸡肋，索性清空自己重头来过。]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
  </entry>
</search>